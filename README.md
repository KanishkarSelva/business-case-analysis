# Business Case of E-Commerce

## Disclaimer

This analysis is based on the data provided and reflects the state of the dataset as of the time of the analysis. The insights and recommendations are derived solely from my point of view and the dataset in question and do not necessarily represent the broader operations or circumstances of the company. The analysis assumes the accuracy of the data as received and has not been independently verified. Future analyses may yield different insights as new data becomes available or as business conditions change.

## Note on Results

Due to the large volume of results generated by this analysis, only a subset has been presented here to illustrate the key trends and patterns. Specifically, the top 10 to 15 results have been included as screenshots to provide a snapshot of the most relevant findings. For a complete view of the data and to explore additional insights, please refer to the full dataset.

---

## Q1.1: Data Type of All Columns in the "customers" Table

### Query

```sql
SELECT column_name, data_type
FROM `ecom.INFORMATION_SCHEMA.COLUMNS`
WHERE table_name = 'customers'
```

**Screenshot**

![](Images/Aspose.Words.f392bb6f-7625-4882-87a6-4dc91ee39796.001.png)

## Insights
- The query reveals the data structure of the customers table, highlighting that it comprises columns with data types of both String and Int64. Understanding the data types is crucial for data integrity and query optimization. For instance, knowing that customer_id is an Int64 assures us it can handle large numeric values efficiently, while customer_name being a String indicates it's designed to store textual data, which is essential for personalization and identification.

## Recommendations
- Data Type Consistency: Ensure consistency in the data types used across the database to prevent type mismatch errors. For instance, if customer_id references another table, both should be of type Int64.
- Query Optimization: Use the knowledge of data types to optimize queries. Knowing a column is an Int64 allows for numerical operations and optimizations, while String operations might require different indexing strategies.
- Data Validation: Implement robust data validation rules, especially for String fields, to maintain data quality. For example, setting maximum lengths on String fields can help avoid data truncation errors.

---

## Q1.2: Get the Time Range Between Which the Orders Were Placed

### Query

```sql
SELECT MIN(order_purchase_timestamp) AS earliest_order_time, MAX(order_purchase_timestamp) AS latest_order_time
FROM `ecom.orders`
```
**Screenshot**

![](Images.Aspose.Words.f392bb6f-7625-4882-87a6-4dc91ee39796.002.png)

## Insights
- This query identifies the time range within which all orders in the dataset were placed, from the earliest to the latest. Specifically, the orders span from 2016-09-04 21:15:19 UTC to 2018-10-17 17:30:18 UTC. This time frame is critical for understanding the period under analysis, allowing for temporal insights into customer behavior, order volume trends, and seasonal impacts on sales.

## Recommendations
- Temporal Analysis for Business Insights: Use this time range to conduct further temporal analyses, such as identifying peak sales periods, understanding seasonal variations in order volume, and correlating sales data with marketing campaigns or major events within the same timeframe.
- Data Completeness Verification: Verify that the data set completeness aligns with this time range. If there are missing dates or discrepancies, it might indicate data integrity issues or gaps in the data collection process.
- Strategic Planning and Forecasting: Leverage the identified time range for strategic planning, including stock management, marketing campaigns, and resource allocation. Understanding the timeline can help predict future trends based on past patterns.
